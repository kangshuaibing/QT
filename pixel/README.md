转自：[像素画](https://blog.csdn.net/ZJU_fish1996/article/details/52266463) 

**像素画工具**
    像素画是以像素为基本单位进行绘制的画。同时，它也是一种设计风格，常用于图标（ICon）设计、logo设计、表情设计以及经典像素风游戏设计。像素画的绘制上手比较容易，对创作者最基本的要求是对色彩的把握，如明度对比、纯度对比。因为在像素画中，具体的线条概念可以是不明确的，而更多是由色彩来表达形体的。
    开发这款工具的初衷，就是为了方便以后的设计。当然市面上也有类似的产品了，但是很多都不是免费的（当然本来也没有多少设计软件是免费的），我感觉它本身的实现并不难，所以就花了一点时间来自己动手写它。
    现在的功能还不那么完善，但是最基本的功能已经实现了，包括这款工具的所有图标都是用它自身绘制出来的。

**详细设计**
（一）画板
* 事件的重写
    主要的方法是重写了paintEvent（绘制事件）, mouseMoveEvent（鼠标移动事件）, mousePressEvent（鼠标点击事件）, mouseReleaseEvent（鼠标抬起事件）。
    利用状态量来标识当前的绘制状态（如：绘制像素点，绘制空心圆，绘制实心圆……），然后在各种事件中根据当前状态，利用switch case来采取对应的操作，由于工具栏与画板在不同的cpp中，每次改变工具，主窗体都需要发射一个信号通知画板改变状态量，每次修改图像后，都要调用update()来刷新当前画面。
         为了实时显示鼠标移动过程中的绘制状态，需要在一开始启动鼠标轨迹追踪（setMouseTracing（true））。
* 缓存
    在屏幕上显示的网格大小并不是真实的像素大小，而是要大一些。我们用map数组来存储每个网格的颜色信息，每次读取的时候遍历这个数组，把里面存储的颜色一个个显示到屏幕上。每次更新图像时，都要更新map数组。
    此外，因为鼠标移动时也会实时绘制，所以我们另外使用一个集合容器（currentPoint）来维护这些点，每次使用后就及时清空。
    除了当前画板的显示，我们在右侧还提供了实际图像的显示，这个图像由QImage暂存，因为QImage提供了像素点的底层操作。我们显示的时候，是将map数组的所有像素颜色直接调用setPixelColor复制过去的。又因为图像的显示是由主窗口控制的，所以我们提供了一个函数来返回包含这个QImage的QLabel的指针。由于新建的时候这个QImage将不再指向原来的内容，我们会发射一个信号通知主窗口更新图像指针。
 * 撤回与重做
    我们提供了撤回和重做的操作，在这里使用了最简单的方法来实现这一过程。在这里，我们支持30次回退，也就是说我们设计了30个map数组，每个map数组存储着某一时间状态下的完整图像，我们把所有图像当做一个队列来维护，所以我们事实上是通过front（队头）, rear（队尾）,layer(当前层)的修改来完成一系列操作的。这也就意味着，如果用户使用撤销后又继续绘制，新的绘制会覆盖用户原本可以重做的内容。这是因为我们保证了整个撤销重做是线性的，如果我们希望重做的内容不被覆盖，形成的将会是一个复杂的树形分支结构。
* 绘制
    点和矩形的绘制就是普通的绘制，在这里，直线和圆的绘制都使用了Bresenham算法，它们具体是什么原理，可以参考 这里。
      当然，这个算法虽然很经典，但是效果其实并不那么好，因为它最终形成的线是锯齿形的，而不是圆滑的。这并不是说这个算法是不正确的，这是用单一颜色绘制直线（圆）的最好效果了，但是为了达成圆滑的效果，我们往往采用灰度（明度）变化来表现线条的柔和，因为我不知道这个需要用什么算法，所以就没有进一步修改。

* 混色
    由于这里使用了透明度来绘制，就会出现不同透明度颜色混合的现象，所以就要考虑混色，关于混色，可以参考 这里。
* 填色
     颜色填充使用的算法是种子填充法，也就是不断地向四周递归搜索，如果颜色相同的话。我们知道点的邻域有四邻域和八邻域，计算机图形学相关的书籍指出：在填充算法中，我们一般选择四邻域。八邻域往往会导致“过分”填充，而四邻域往往会导致填充“不足”，但是，相比之下，不足是可以弥补的，而过分填充却是难以弥补的，所以我们更倾向于四邻域填充算法。


（二）颜色条

首先这里有两种颜色条，一个是明度颜色条，一个是渐变颜色条。渐变颜色条的实现很简单，就是不断地改变透明度（alpha通道）就可以了。
关于明度变化，QColor中一般使用RGB来存储颜色信息的，一开始我以为要自己去写两种色彩空间（从RGB到HSL）的转换，后来发现qt本身提供了这种转换，所以就直接调用了QColor的这个方法，这样一来，明度变化也很简单的。
至于这个渐变是怎样画出来的，实际上就是从0开始到255，不断变化明度（透明度），然后绘制一个个矩形。每个矩形的宽度就是width()/255，高度就是height()。在这里，我们的颜色与窗口坐标值是对应的，所以我们在点击这个颜色条的时候，也可以通过坐标值迅速的计算出选中的颜色。

